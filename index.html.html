<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Australian Steel Design Assistant</title>
    <style>
        .hidden { display: none; }
        body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 16px; }
        .result-panel { border: 1px solid #ddd; padding: 12px; margin-top: 8px; }
    </style>
</head>
<body>
    <!-- Minimal DOM elements referenced by the script so it can run without errors -->
    <label for="result-view-selector">Result view:</label>
    <select id="result-view-selector" onchange="switchResultView()">
        <option value="summary">Summary</option>
        <option value="detailed">Detailed</option>
        <option value="visual">Visual</option>
        <option value="connections">Connections</option>
    </select>

    <div id="result-summary" class="result-panel">Summary view</div>
    <div id="result-detailed" class="result-panel hidden">Detailed view</div>
    <div id="result-visual" class="result-panel hidden">Visual view</div>
    <div id="result-connections" class="result-panel hidden">Connections view</div>

    <label for="connection-view">Connection view:</label>
    <select id="connection-view" onchange="switchConnectionView()">
        <option value="single">Single</option>
        <option value="double">Double</option>
    </select>

    <div id="point-load-options" class="hidden">Point load options</div>

    <script>
        // Global variables
        let designType = null;
        let currentStep = 1;
        let sectionData = null;
        let connectionData = null;
        let loadingData = null;
        let uploadedImage = null;
        let isDarkMode = false;
        let threeDScene = null;
        
        // Section database
        const sectionDatabase = {
            ub: [
                { size: '610UB125', mass: 125, depth: 612, width: 229, tf: 19.6, tw: 11.9, 
                  Ix: 986000000, Iy: 45600000, Zx: 3560000, Zy: 398000 },
                { size: '610UB113', mass: 113, depth: 607, width: 228, tf: 17.3, tw: 11.2, 
                  Ix: 875000000, Iy: 41300000, Zx: 3180000, Zy: 362000 },
                { size: '530UB92', mass: 92.4, depth: 533, width: 209, tf: 15.6, tw: 10.2, 
                  Ix: 554000000, Iy: 30400000, Zx: 2280000, Zy: 291000 },
                { size: '460UB82', mass: 82.1, depth: 460, width: 191, tf: 16.0, tw: 9.9, 
                  Ix: 370000000, Iy: 22300000, Zx: 1750000, Zy: 233000 },
                { size: '460UB74', mass: 74.6, depth: 457, width: 190, tf: 14.5, tw: 9.1, 
                  Ix: 333000000, Iy: 20100000, Zx: 1580000, Zy: 212000 },
                { size: '410UB60', mass: 59.7, depth: 406, width: 178, tf: 12.8, tw: 7.8, 
                  Ix: 216000000, Iy: 13600000, Zx: 1160000, Zy: 153000 },
                { size: '360UB57', mass: 56.7, depth: 358, width: 172, tf: 13.8, tw: 8.1, 
                  Ix: 161000000, Iy: 11700000, Zx: 992000, Zy: 136000 },
                { size: '310UB46', mass: 46.2, depth: 308, width: 166, tf: 11.8, tw: 6.7,
                  Ix: 94100000, Iy: 8650000, Zx: 674000, Zy: 104000 },
                { size: '250UB37', mass: 37.3, depth: 256, width: 146, tf: 10.9, tw: 6.4,
                  Ix: 49900000, Iy: 4360000, Zx: 427000, Zy: 59700 },
                { size: '200UB29', mass: 29.8, depth: 207, width: 134, tf: 9.6, tw: 6.3,
                  Ix: 26700000, Iy: 2690000, Zx: 279000, Zy: 40100 }
            ],
            uc: [
                { size: '310UC158', mass: 158, depth: 327, width: 311, tf: 25.0, tw: 15.7, 
                  Ix: 476000000, Iy: 149000000, Zx: 3250000, Zy: 958000 },
                { size: '310UC137', mass: 137, depth: 320, width: 309, tf: 21.7, tw: 13.8, 
                  Ix: 397000000, Iy: 127000000, Zx: 2760000, Zy: 823000 },
                { size: '250UC89', mass: 89.5, depth: 260, width: 256, tf: 17.3, tw: 10.5, 
                  Ix: 142000000, Iy: 44900000, Zx: 1230000, Zy: 351000 },
                { size: '200UC60', mass: 59.5, depth: 210, width: 205, tf: 14.2, tw: 9.3, 
                  Ix: 60800000, Iy: 18700000, Zx: 666000, Zy: 182000 },
                { size: '200UC52', mass: 52.2, depth: 206, width: 204, tf: 12.5, tw: 8.0, 
                  Ix: 52800000, Iy: 16400000, Zx: 578000, Zy: 161000 },
                { size: '150UC37', mass: 37.2, depth: 162, width: 154, tf: 11.5, tw: 8.0, 
                  Ix: 22200000, Iy: 6060000, Zx: 327000, Zy: 78700 },
                { size: '150UC30', mass: 30.0, depth: 158, width: 153, tf: 9.4, tw: 6.6,
                  Ix: 17400000, Iy: 4860000, Zx: 261000, Zy: 63500 },
                { size: '100UC15', mass: 14.8, depth: 100, width: 100, tf: 6.0, tw: 5.0,
                  Ix: 3830000, Iy: 1250000, Zx: 86800, Zy: 25000 }
            ],
            pfc: [
                { size: '380PFC', mass: 55.2, depth: 380, width: 100, tf: 17.5, tw: 10.0, 
                  Ix: 332000000, Iy: 8180000, Zx: 1950000, Zy: 124000 },
                { size: '300PFC', mass: 40.1, depth: 300, width: 90, tf: 15.5, tw: 9.0, 
                  Ix: 145000000, Iy: 4770000, Zx: 1070000, Zy: 79400 },
                { size: '250PFC', mass: 35.5, depth: 250, width: 90, tf: 15.0, tw: 8.0, 
                  Ix: 88700000, Iy: 4250000, Zx: 780000, Zy: 71700 },
                { size: '230PFC', mass: 32.1, depth: 230, width: 75, tf: 13.5, tw: 7.5, 
                  Ix: 64400000, Iy: 2210000, Zx: 612000, Zy: 44200 },
                { size: '200PFC', mass: 29.8, depth: 200, width: 75, tf: 12.5, tw: 7.0, 
                  Ix: 44500000, Iy: 1960000, Zx: 497000, Zy: 40100 },
                { size: '180PFC', mass: 26.0, depth: 180, width: 75, tf: 11.0, tw: 6.0,
                  Ix: 33200000, Iy: 1740000, Zx: 413000, Zy: 35900 },
                { size: '150PFC', mass: 22.1, depth: 150, width: 75, tf: 9.5, tw: 5.0,
                  Ix: 19100000, Iy: 1380000, Zx: 288000, Zy: 30000 }
            ],
            rhs: [
                { size: '400x300x16RHS', mass: 154, depth: 400, width: 300, thickness: 16, 
                  Ix: 397000000, Iy: 241000000, Zx: 2380000, Zy: 1880000 },
                { size: '350x250x12.5RHS', mass: 102, depth: 350, width: 250, thickness: 12.5, 
                  Ix: 211000000, Iy: 125000000, Zx: 1400000, Zy: 1120000 },
                { size: '300x200x10RHS', mass: 73.6, depth: 300, width: 200, thickness: 10, 
                  Ix: 114000000, Iy: 60400000, Zx: 845000, Zy: 671000 },
                { size: '250x150x9RHS', mass: 51.8, depth: 250, width: 150, thickness: 9, 
                  Ix: 55000000, Iy: 23400000, Zx: 495000, Zy: 356000 },
                { size: '200x100x6RHS', mass: 26.7, depth: 200, width: 100, thickness: 6, 
                  Ix: 20400000, Iy: 6130000, Zx: 232000, Zy: 141000 },
                { size: '150x100x5RHS', mass: 18.6, depth: 150, width: 100, thickness: 5,
                  Ix: 7530000, Iy: 3820000, Zx: 115000, Zy: 90200 },
                { size: '125x75x4RHS', mass: 11.7, depth: 125, width: 75, thickness: 4,
                  Ix: 3210000, Iy: 1320000, Zx: 58700, Zy: 40600 }
            ],
            shs: [
                { size: '350x350x16SHS', mass: 172, width: 350, thickness: 16, 
                  Ix: 348000000, Iy: 348000000, Zx: 2330000, Zy: 2330000 },
                { size: '300x300x12.5SHS', mass: 112, width: 300, thickness: 12.5, 
                  Ix: 176000000, Iy: 176000000, Zx: 1380000, Zy: 1380000 },
                { size: '250x250x12.5SHS', mass: 92, width: 250, thickness: 12.5, 
                  Ix: 100000000, Iy: 100000000, Zx: 943000, Zy: 943000 },
                { size: '200x200x9SHS', mass: 52.4, width: 200, thickness: 9, 
                  Ix: 42700000, Iy: 42700000, Zx: 499000, Zy: 499000 },
                { size: '150x150x9SHS', mass: 38.3, width: 150, thickness: 9, 
                  Ix: 17200000, Iy: 17200000, Zx: 274000, Zy: 274000 },
                { size: '125x125x5SHS', mass: 18.4, width: 125, thickness: 5,
                  Ix: 5310000, Iy: 5310000, Zx: 99900, Zy: 99900 },
                { size: '100x100x5SHS', mass: 14.4, width: 100, thickness: 5,
                  Ix: 2690000, Iy: 2690000, Zx: 64200, Zy: 64200 },
                { size: '75x75x4SHS', mass: 8.55, width: 75, thickness: 4,
                  Ix: 912000, Iy: 912000, Zx: 29300, Zy: 29300 }
            ],
            angle: [
                { size: '150x150x18EA', mass: 39.5, leg: 150, thickness: 18,
                  Ix: 12300000, Iy: 12300000, Zx: 114000, Zy: 114000 },
                { size: '125x125x12EA', mass: 22.2, leg: 125, thickness: 12,
                  Ix: 4530000, Iy: 4530000, Zx: 51200, Zy: 51200 },
                { size: '100x100x12EA', mass: 17.6, leg: 100, thickness: 12,
                  Ix: 2290000, Iy: 2290000, Zx: 32300, Zy: 32300 },
                { size: '75x75x10EA', mass: 10.9, leg: 75, thickness: 10,
                  Ix: 787000, Iy: 787000, Zx: 15000, Zy: 15000 },
                { size: '65x65x5EA', mass: 4.9, leg: 65, thickness: 5,
                  Ix: 302000, Iy: 302000, Zx: 6580, Zy: 6580 }
            ],
            uangle: [
                { size: '150x100x12UA', mass: 22.1, legH: 150, legV: 100, thickness: 12,
                  Ix: 5980000, Iy: 1950000, Zx: 57200, Zy: 28400 },
                { size: '125x75x10UA', mass: 14.6, legH: 125, legV: 75, thickness: 10,
                  Ix: 2640000, Iy: 660000, Zx: 31200, Zy: 12700 },
                { size: '100x75x8UA', mass: 10.3, legH: 100, legV: 75, thickness: 8,
                  Ix: 1220000, Iy: 526000, Zx: 17900, Zy: 10500 },
                { size: '75x50x5UA', mass: 4.64, legH: 75, legV: 50, thickness: 5,
                  Ix: 341000, Iy: 104000, Zx: 6730, Zy: 3130 }
            ],
            chs: [
                { size: '406x12.7CHS', mass: 123, diameter: 406, thickness: 12.7,
                  Ix: 230000000, Iy: 230000000, Zx: 1320000, Zy: 1320000 },
                { size: '355x9.5CHS', mass: 80.7, diameter: 355, thickness: 9.5,
                  Ix: 115000000, Iy: 115000000, Zx: 756000, Zy: 756000 },
                { size: '273x9.3CHS', mass: 59.9, diameter: 273, thickness: 9.3,
                  Ix: 45900000, Iy: 45900000, Zx: 391000, Zy: 391000 },
                { size: '219x8.2CHS', mass: 42.5, diameter: 219, thickness: 8.2,
                  Ix: 22300000, Iy: 22300000, Zx: 237000, Zy: 237000 },
                { size: '168x6.4CHS', mass: 25.4, diameter: 168, thickness: 6.4,
                  Ix: a890000, Iy: 8890000, Zx: 125000, Zy: 125000 },
                { size: '114x6.0CHS', mass: 16.0, diameter: 114, thickness: 6.0,
                  Ix: 2360000, Iy: 2360000, Zx: 48900, Zy: 48900 },
                { size: '88.9x5.0CHS', mass: 10.3, diameter: 88.9, thickness: 5.0,
                  Ix: a890000, Iy: 889000, Zx: 23800, Zy: 23800 }
            ]
        };
        
        // Engineering constants
        const CONSTANTS = {
            // Capacity factors (AS 4100-2020)
            PHI: {
                MOMENT: 0.9,
                SHEAR: 0.9,
                TENSION: 0.9,
                COMPRESSION: 0.9,
                BEARING: 0.9,
                BOLT_SHEAR: 0.8,
                BOLT_TENSION: 0.8,
                WELD: 0.8
            },
            
            // Steel grades
            STEEL_GRADE: {
                '300': {
                    fy: 300,
                    fu: 440,
                    E: 200000,
                    G: 80000,
                    v: 0.3
                },
                '350': {
                    fy: 350,
                    fu: 480,
                    E: 200000,
                    G: 80000,
                    v: 0.3
                },
                '400': {
                    fy: 400,
                    fu: 520,
                    E: 200000,
                    G: 80000,
                    v: 0.3
                },
                '450': {
                    fy: 450, 
                    fu: 550,
                    E: 200000,
                    G: 80000,
                    v: 0.3
                }
            },
            
            // Bolt grades
            BOLT_GRADE: {
                '4.6': {
                    fyb: 240,
                    fub: 400
                },
                '8.8': {
                    fyb: 640,
                    fub: 800
                },
                '10.9': {
                    fyb: 900,
                    fub: 1000
                }
            },
            
            // Load combination factors (AS/NZS 1170.0)
            LOAD_FACTORS: {
                DEAD: 1.35,
                DEAD_WITH_LIVE: 1.2,
                LIVE: 1.5,
                WIND: 1.0,
                SNOW: 0.5
            }
        };
        
        // Set up event listeners when the DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            setupEventListeners();
            setupDragAndDrop();
            showNotification('Application loaded successfully', 'success');
        });
        
        // Initialize the app
        function initializeApp() {
            // Initialize the section sizes dropdown
            updateSectionSizes();
            
            // Show the first step
            updateStepDisplay();
            
            // Set up event handlers for keyboard navigation
            setupKeyboardNavigation();
            
            // Check for saved preferences (dark mode, etc.)
            checkSavedPreferences();
        }
        
        // Set up all event listeners
        function setupEventListeners() {
            // Navigation buttons
            document.getElementById('prev-button').addEventListener('click', previousStep);
            document.getElementById('next-button').addEventListener('click', nextStep);
            
            // Step indicators for direct navigation
            document.querySelectorAll('.step-circle').forEach(function(circle) {
                circle.addEventListener('click', function() {
                    const step = parseInt(this.textContent);
                    if (step < currentStep) {
                        goToStep(step);
                    }
                });
            });
            
            // Dynamic form elements
            document.getElementById('load-type').addEventListener('change', function() {
                const loadType = this.value;
                document.getElementById('point-load-options').classList.toggle('hidden', loadType !== 'point');
            });
            
            // Form validation
            document.querySelectorAll('input[type="number"]').forEach(function(input) {
                input.addEventListener('input', validateInput);
            });
            
            // Loading type radio buttons
            document.querySelectorAll('input[name="loading-type"]').forEach(function(radio) {
                radio.addEventListener('change', function() {
                    toggleLoadingType(this.value);
                });
            });
            
            // Live load type dropdown
            document.getElementById('live-load-type').addEventListener('change', function() {
                document.getElementById('custom-live-load').classList.toggle('hidden', this.value !== 'custom');
            });
            
            // Snow load region dropdown
            document.getElementById('snow-load-region').addEventListener('change', function() {
                document.getElementById('custom-snow-load').classList.toggle('hidden', this.value !== 'custom');
            });
            
            // Load combination standard dropdown
            document.getElementById('load-combination-standard').addEventListener('change', function() {
                document.getElementById('standard-combinations').classList.toggle('hidden', this.value !== 'as1170');
                document.getElementById('custom-combinations').classList.toggle('hidden', this.value !== 'custom');
            });
            
            // Result view selector
            document.getElementById('result-view-selector').addEventListener('change', switchResultView);
        }
        
        // Setup drag and drop functionality
        function setupDragAndDrop() {
            const dropArea = document.getElementById('drop-area');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight() {
                dropArea.classList.add('drag-over');
            }
            
            function unhighlight() {
                dropArea.classList.remove('drag-over');
            }
            
            dropArea.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length) {
                    handleFileUpload({ target: { files: files } });
                }
            }
        }
        
        // Set up keyboard navigation
        function setupKeyboardNavigation() {
            document.addEventListener('keydown', function(e) {
                // Enter key for selection
                if (e.key === 'Enter') {
                    const focused = document.activeElement;
                    if (focused && focused.classList.contains('choice-card')) {
                        focused.click();
                    }
                }
                
                // Arrow keys for navigation
                if (e.key === 'ArrowRight' && !document.getElementById('next-button').disabled) {
                    nextStep();
                } else if (e.key === 'ArrowLeft' && !document.getElementById('prev-button').disabled) {
                    previousStep();
                }
            });
        }
        
        // Check for saved preferences
        function checkSavedPreferences() {
            // Check if dark mode was previously enabled
            const darkModePref = localStorage.getItem('darkMode');
            if (darkModePref === 'true') {
                toggleDarkMode();
            }
        }
        
        // Toggle dark mode
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            isDarkMode = document.body.classList.contains('dark-mode');
            
            // Update icon
            const themeToggle = document.querySelector('.theme-toggle');
            themeToggle.innerHTML = isDarkMode ? '☀️' : '🌙';
            
            // Save preference
            localStorage.setItem('darkMode', isDarkMode);
        }
        
        // Select design type
        function selectDesignType(type) {
            designType = type;
            
            // Update UI
            document.getElementById('single-member').classList.remove('selected');
            document.getElementById('frame-design').classList.remove('selected');
            
            document.getElementById(type + '-member').classList.add('selected');
            document.getElementById('next-button').disabled = false;
            
            // Update ARIA attributes
            document.getElementById('single-member').setAttribute('aria-pressed', type === 'single');
            document.getElementById('frame-design').setAttribute('aria-pressed', type === 'frame');
            
            // Show notification
            showNotification(`${type.charAt(0).toUpperCase() + type.slice(1)} member design selected`, 'success');
        }
        
        // Navigate to next step
        function nextStep() {
            // Validate current step data
            if (!validateCurrentStep()) {
                showNotification('Please correct the errors before continuing', 'error');
                return;
            }
            
            // Save data from current step
            saveCurrentStepData();
            
            if (currentStep < 4) {
                currentStep++;
                updateStepDisplay();
                
                // Initialize the new step
                initializeStep(currentStep);
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            } else {
                // Finish the design
                downloadDesign();
            }
        }
        
        // Navigate to previous step
        function previousStep() {
            if (currentStep > 1) {
                currentStep--;
                updateStepDisplay();
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }
        
        // Go to a specific step (for step indicators)
        function goToStep(step) {
            if (step >= 1 && step <= currentStep && step <= 4) {
                currentStep = step;
                updateStepDisplay();
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }
        
        // Update step display
        function updateStepDisplay() {
            // Hide all steps
            document.getElementById('step1').classList.add('hidden');
            document.getElementById('step2').classList.add('hidden');
            document.getElementById('step3').classList.add('hidden');
            document.getElementById('step4').classList.add('hidden');
            
            // Show current step
            document.getElementById('step' + currentStep).classList.remove('hidden');
            
            // Update step indicators
            for (let i = 1; i <= 4; i++) {
                const indicator = document.getElementById('step' + i + '-indicator');
                indicator.classList.remove('active', 'completed');
                indicator.setAttribute('aria-selected', i === currentStep);
                indicator.tabIndex = i === currentStep ? 0 : -1;
                
                if (i < currentStep) {
                    indicator.classList.add('completed');
                } else if (i === currentStep) {
                    indicator.classList.add('active');
                }
            }
            
            // Update connecting lines
            for (let i = 1; i < 4; i++) {
                const line = document.getElementById('line' + i + '-' + (i+1));
                if (line) {
                    if (i < currentStep) {
                        line.classList.add('completed');
                    } else {
                        line.classList.remove('completed');
                    }
                }
            }
            
            // Update navigation buttons
            document.getElementById('prev-button').disabled = (currentStep === 1);
            
            const nextButton = document.getElementById('next-button');
            nextButton.textContent = (currentStep === 4) ? 'Download' : 'Next';
            
            if (currentStep === 1) {
                nextButton.disabled = (designType === null);
            } else {
                nextButton.disabled = false;
            }
        }
        
        // Initialize a step
        function initializeStep(step) {
            switch (step) {
                case 2:
                    // Member specifications
                    if (designType === 'single') {
                        document.getElementById('single-member-form').classList.remove('hidden');
                        document.getElementById('frame-design-form').classList.add('hidden');
                    } else {
                        document.getElementById('single-member-form').classList.add('hidden');
                        document.getElementById('frame-design-form').classList.remove('hidden');
                    }
                    break;
                    
                case 3:
                    // Initialize loading forms
                    toggleLoadingType('simple');
                    break;
                    
                case 4:
                    // Generate results
                    generateResults();
                    initializeVisualization();
                    break;
                    
                default:
                    break;
            }
        }
        
        // Validate current step
        function validateCurrentStep() {
            let isValid = true;
            
            switch (currentStep) {
                case 1:
                    // Validate design type selection
                    isValid = designType !== null;
                    break;
                    
                case 2:
                    // Validate member specifications
                    if (designType === 'single') {
                        // Validate member length
                        const memberLength = document.getElementById('member-length').value;
                        if (memberLength < 100) {
                            isValid = false;
                        }
                    } else {
                        // Validate frame dimensions if a frame is uploaded
                        if (uploadedImage) {
                            const frameWidth = document.getElementById('frame-width').value;
                            const frameHeight = document.getElementById('frame-height').value;
                            if (frameWidth < 1000 || frameHeight < 1000) {
                                isValid = false;
                            }
                        } else {
                            isValid = false;
                            showNotification('Please upload a frame sketch', 'error');
                        }
                    }
                    break;
                    
                case 3:
                    // Validate loading information
                    const deadLoad = parseFloat(document.getElementById('dead-load').value);
                    const liveLoad = parseFloat(document.getElementById('live-load').value);
                    
                    if (isNaN(deadLoad) || deadLoad < 0 || isNaN(liveLoad) || liveLoad < 0) {
                        isValid = false;
                    }
                    break;
                    
                default:
                    break;
            }
            
            return isValid;
        }
        
        // Validate individual input
        function validateInput(e) {
            const input = e.target;
            const value = parseFloat(input.value);
            const min = parseFloat(input.min);
            
            if (isNaN(value) || value < min) {
                input.setCustomValidity('Invalid value');
                input.classList.add('invalid');
            } else {
                input.setCustomValidity('');
                input.classList.remove('invalid');
            }
        }
        
        // Save data from the current step
        function saveCurrentStepData() {
            switch (currentStep) {
                case 2:
                    // Member specifications
                    if (designType === 'single') {
                        sectionData = {
                            memberType: document.getElementById('member-type').value,
                            sectionType: document.getElementById('section-type').value,
                            sectionSize: document.getElementById('section-size').value,
                            length: parseFloat(document.getElementById('member-length').value),
                            steelGrade: document.getElementById('steel-grade').value
                        };
                        
                        // Find section in database
                        sectionData.section = findSection(sectionData.sectionType, sectionData.sectionSize);
                        
                        // Get advanced connection data
                        connectionData = {
                            connectionType: document.getElementById('connection-type').value,
                            connectionMethod: document.getElementById('connection-method').value,
                            boltDiameter: document.getElementById('bolt-diameter').value,
                            boltGrade: document.getElementById('bolt-grade').value,
                            numBolts: parseInt(document.getElementById('num-bolts').value),
                            edgeDistance: parseFloat(document.getElementById('edge-distance').value),
                            weldSize: parseFloat(document.getElementById('weld-size').value),
                            weldType: document.getElementById('weld-type').value
                        };
                    } else {
                        // Frame data
                        connectionData = {
                            connectionType: document.getElementById('frame-connection-type').value,
                            connectionMethod: document.getElementById('frame-connection-method').value,
                            frameWidth: parseFloat(document.getElementById('frame-width').value),
                            frameHeight: parseFloat(document.getElementById('frame-height').value)
                        };
                    }
                    break;
                    
                case 3:
                    // Loading conditions
                    const loadingType = document.querySelector('input[name="loading-type"]:checked').value;
                    
                    if (loadingType === 'simple') {
                        loadingData = {
                            deadLoad: parseFloat(document.getElementById('dead-load').value),
                            liveLoad: parseFloat(document.getElementById('live-load').value),
                            windLoad: parseFloat(document.getElementById('wind-load').value),
                            snowLoad: parseFloat(document.getElementById('snow-load').value),
                            loadType: document.getElementById('load-type').value
                        };
                        
                        if (loadingData.loadType === 'point') {
                            loadingData.pointPosition = parseInt(document.getElementById('point-load-position').value) / 100;
                        }
                    } else {
                        // Advanced loading data
                        loadingData = {
                            advanced: true,
                            includeSelfWeight: document.getElementById('include-self-weight').checked,
                            permanentDistributed: parseFloat(document.getElementById('permanent-distributed-load').value),
                            permanentPoint: parseFloat(document.getElementById('permanent-point-load').value),
                            permanentPointPosition: parseFloat(document.getElementById('permanent-point-position').value),
                            liveLoadType: document.getElementById('live-load-type').value,
                            windRegion: document.getElementById('wind-region').value,
                            terrainCategory: document.getElementById('terrain-category').value,
                            buildingImportance: document.getElementById('building-importance').value
                        };
                        
                        // Get selected live load patterns
                        const liveLoadPatterns = [];
                        document.querySelectorAll('#live-load-patterns option:checked').forEach(function(option) {
                            liveLoadPatterns.push(option.value);
                        });
                        loadingData.liveLoadPatterns = liveLoadPatterns;
                        
                        // Get custom load values if specified
                        if (loadingData.liveLoadType === 'custom') {
                            loadingData.customLiveLoad = parseFloat(document.getElementById('custom-live-load-intensity').value);
                            loadingData.customLiveLoadFactor = parseFloat(document.getElementById('custom-live-load-factor').value);
                        }
                        
                        // Snow load
                        loadingData.snowLoadRegion = document.getElementById('snow-load-region').value;
                        if (loadingData.snowLoadRegion === 'custom') {
                            loadingData.customSnowLoad = parseFloat(document.getElementById('custom-snow-load-value').value);
                        }
                        
                        // Load combinations
                        loadingData.loadCombinationStandard = document.getElementById('load-combination-standard').value;
                        loadingData.includeServiceability = document.getElementById('use-serviceability').checked;
                        
                        if (loadingData.loadCombinationStandard === 'custom') {
                            const combinations = [];
                            document.querySelectorAll('.load-combination').forEach(function(combo, index) {
                                combinations.push({
                                    deadFactor: parseFloat(document.getElementById(`combo${index+1}-g-factor`).value),
                                    liveFactor: parseFloat(document.getElementById(`combo${index+1}-q-factor`).value),
                                    windFactor: parseFloat(document.getElementById(`combo${index+1}-w-factor`).value),
                                    snowFactor: parseFloat(document.getElementById(`combo${index+1}-s-factor`).value)
                                });
                            });
                            loadingData.customCombinations = combinations;
                        }
                    }
                    break;
                    
                default:
                    break;
            }
        }
        
        // Show notification
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            const messageElement = document.getElementById('notification-message');
            const iconElement = document.getElementById('notification-icon');
            
            // Set message
            messageElement.textContent = message;
            
            // Set icon based on type
            if (type === 'success') {
                iconElement.textContent = '✓';
                notification.className = 'notification notification-success';
            } else if (type === 'error') {
                iconElement.textContent = '✗';
                notification.className = 'notification notification-error';
            } else {
                iconElement.textContent = 'ℹ️';
                notification.className = 'notification';
            }
            
            // Show notification
            notification.classList.add('show');
            
            // Hide after 3 seconds
            setTimeout(hideNotification, 3000);
        }
        
        // Hide notification
        function hideNotification() {
            const notification = document.getElementById('notification');
            notification.classList.remove('show');
        }
        
        // Toggle advanced connection options
        function toggleAdvancedConnections() {
            const advancedOptions = document.getElementById('advanced-connection-options');
            advancedOptions.classList.toggle('hidden');
            
            // Update button text
            const button = document.getElementById('advanced-connection-btn');
            if (advancedOptions.classList.contains('hidden')) {
                button.innerHTML = '<span class="btn-icon">⚙️</span> Advanced Connection Options';
            } else {
                button.innerHTML = '<span class="btn-icon">⚙️</span> Hide Advanced Options';
            }
        }
        
        // Toggle loading type (simple vs advanced)
        function toggleLoadingType(type) {
            document.getElementById('simple-loading-form').classList.toggle('hidden', type !== 'simple');
            document.getElementById('advanced-loading-form').classList.toggle('hidden', type !== 'advanced');
        }
        
        // Add a new load combination
        function addLoadCombination() {
            const container = document.getElementById('load-combinations');
            const index = container.children.length + 1;
            
            const comboDiv = document.createElement('div');
            comboDiv.className = 'load-combination p-4 rounded border bg-light mb-2';
            comboDiv.innerHTML = `
                <div class="flex justify-between mb-2">
                    <h4>Combination ${index}</h4>
                    <button type="button" class="remove-btn" onclick="removeLoadCombination(this)">✕</button>
                </div>
                
                <div class="flex flex-col md:flex-row gap-4">
                    <div class="form-group w-full">
                        <label for="combo${index}-g-factor">Dead Load Factor</label>
                        <input type="number" id="combo${index}-g-factor" value="1.2" step="0.1">
                    </div>
                    
                    <div class="form-group w-full">
                        <label for="combo${index}-q-factor">Live Load Factor</label>
                        <input type="number" id="combo${index}-q-factor" value="1.5" step="0.1">
                    </div>
                    
                    <div class="form-group w-full">
                        <label for="combo${index}-w-factor">Wind Load Factor</label>
                        <input type="number" id="combo${index}-w-factor" value="0" step="0.1">
                    </div>
                    
                    <div class="form-group w-full">
                        <label for="combo${index}-s-factor">Snow Load Factor</label>
                        <input type="number" id="combo${index}-s-factor" value="0" step="0.1">
                    </div>
                </div>
            `;
            
            container.appendChild(comboDiv);
        }
        
        // Remove a load combination
        function removeLoadCombination(button) {
            const combo = button.closest('.load-combination');
            combo.parentNode.removeChild(combo);
            
            // Renumber remaining combinations
            const combinations = document.querySelectorAll('.load-combination');
            combinations.forEach(function(combo, index) {
                const title = combo.querySelector('h4');
                title.textContent = `Combination ${index + 1}`;
                
                // Update input IDs
                const inputs = combo.querySelectorAll('input');
                inputs.forEach(function(input) {
                    const newId = input.id.replace(/combo\d+/, `combo${index + 1}`);
                    const label = combo.querySelector(`label[for="${input.id}"]`);
                    
                    input.id = newId;
                    label.setAttribute('for', newId);
                });
            });
        }
        
        // Update point load position display
        function updatePointLoadDisplay() {
            const position = document.getElementById('point-load-position').value;
            document.getElementById('point-load-display').textContent = `Position: ${position}% of span`;
        }
        
        // Update section sizes dropdown
        function updateSectionSizes() {
            const sectionTypeSelect = document.getElementById('section-type');
            const sectionSizeSelect = document.getElementById('section-size');
            
            if (!sectionTypeSelect || !sectionSizeSelect) return;
            
            const sectionType = sectionTypeSelect.value;
            
            // Clear existing options
            sectionSizeSelect.innerHTML = '';
            
            // Add new options
            if (sectionDatabase[sectionType]) {
                sectionDatabase[sectionType].forEach(section => {
                    const option = document.createElement('option');
                    option.value = section.size;
                    option.textContent = `${section.size} (${section.mass} kg/m)`;
                    sectionSizeSelect.appendChild(option);
                });
                
                // Update section details
                updateSectionDetails();
            }
        }
        
        // Update section details display
        function updateSectionDetails() {
            const sectionTypeSelect = document.getElementById('section-type');
            const sectionSizeSelect = document.getElementById('section-size');
            const detailsDiv = document.getElementById('section-details');
            
            if (!sectionTypeSelect || !sectionSizeSelect || !detailsDiv) return;
            
            const sectionType = sectionTypeSelect.value;
            const sectionSize = sectionSizeSelect.value;
            
            // Find section in database
            const section = findSection(sectionType, sectionSize);
            
            if (section) {
                // Create HTML for section details
                let html = '';
                
                // Always show weight
                html += `<div class="section-property">Weight: ${section.mass} kg/m</div>`;
                
                // Show dimensions based on section type
                if (section.hasOwnProperty('depth')) {
                    html += `<div class="section-property">Depth: ${section.depth} mm</div>`;
                }
                
                if (section.hasOwnProperty('width')) {
                    html += `<div class="section-property">Width: ${section.width} mm</div>`;
                }
                
                if (section.hasOwnProperty('diameter')) {
                    html += `<div class="section-property">Diameter: ${section.diameter} mm</div>`;
                }
                
                if (section.hasOwnProperty('leg')) {
                    html += `<div class="section-property">Leg: ${section.leg} mm</div>`;
                }
                
                if (section.hasOwnProperty('legH') && section.hasOwnProperty('legV')) {
                    html += `<div class="section-property">Legs: ${section.legH}×${section.legV} mm</div>`;
                }
                
                if (section.hasOwnProperty('tf')) {
                    html += `<div class="section-property">Flange: ${section.tf} mm</div>`;
                }
                
                if (section.hasOwnProperty('tw')) {
                    html += `<div class="section-property">Web: ${section.tw} mm</div>`;
                }
                
                if (section.hasOwnProperty('thickness')) {
                    html += `<div class="section-property">Thickness: ${section.thickness} mm</div>`;
                }
                
                // Add section properties for advanced users
                html += `<div class="section-property">Ix: ${formatNumber(section.Ix)} mm⁴</div>`;
                html += `<div class="section-property">Zx: ${formatNumber(section.Zx)} mm³</div>`;
                
                detailsDiv.innerHTML = html;
            }
        }
        
        // Format large numbers with SI prefixes
        function formatNumber(value) {
            if (value >= 1e9) {
                return (value / 1e9).toFixed(2) + ' G';
            } else if (value >= 1e6) {
                return (value / 1e6).toFixed(2) + ' M';
            } else if (value >= 1e3) {
                return (value / 1e3).toFixed(2) + ' k';
            } else {
                return value.toFixed(2);
            }
        }
        
        // Handle file upload
        function handleFileUpload(event) {
            const file = event.target.files[0];
            
            if (file) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    uploadedImage = e.target.result;
                    
                    const previewImage = document.getElementById('preview-image');
                    const previewContainer = document.getElementById('preview-container');
                    
                    if (previewImage && previewContainer) {
                        previewImage.src = uploadedImage;
                        previewContainer.classList.remove('hidden');
                        
                        // Show notification
                        showNotification('File uploaded successfully', 'success');
                    }
                };
                
                reader.onerror = function() {
                    showNotification('Error reading file', 'error');
                };
                
                reader.readAsDataURL(file);
            }
        }
        
        // Update connection options based on connection type
        function updateConnectionOptions() {
            const connectionTypeSelect = document.getElementById('connection-type');
            const optionsDiv = document.getElementById('connection-options');
            
            if (!connectionTypeSelect || !optionsDiv) return;
            
            const connectionType = connectionTypeSelect.value;
            
            // Clear existing options
            optionsDiv.innerHTML = '';
            
            // Add different options based on connection type
            if (connectionType === 'column' || connectionType === 'beam') {
                let html = '<div class="form-group">';
                html += `<label for="support-section">Support Section:</label>`;
                html += '<select id="support-section">';
                
                // Add appropriate section options
                const sectionType = connectionType === 'column' ? 'uc' : 'ub';
                
                if (sectionDatabase[sectionType]) {
                    sectionDatabase[sectionType].forEach(section => {
                        html += `<option value="${section.size}">${section.size}</option>`;
                    });
                }
                
                html += '</select>';
                html += '</div>';
                
                // Add orientation option
                html += '<div class="form-group mt-4">';
                html += '<label for="connection-orientation">Connection Orientation:</label>';
                html += '<select id="connection-orientation">';
                html += '<option value="flush">Flush/Centered</option>';
                html += '<option value="offset">Offset</option>';
                html += '</select>';
                html += '</div>';
                
                // Add offset input if needed
                html += '<div id="offset-options" class="hidden">';
                html += '<div class="form-group">';
                html += '<label for="connection-offset">Offset Distance (mm):</label>';
                html += '<input type="number" id="connection-offset" value="0">';
                html += '</div>';
                html += '</div>';
                
                optionsDiv.innerHTML = html;
                
                // Add event listener for orientation change
                document.getElementById('connection-orientation').addEventListener('change', function() {
                    document.getElementById('offset-options').classList.toggle('hidden', this.value !== 'offset');
                });
            } else if (connectionType === 'wall') {
                let html = '<div class="form-group">';
                html += '<label for="wall-material">Wall Material:</label>';
                html += '<select id="wall-material">';
                html += '<option value="concrete">Concrete</option>';
                html += '<option value="masonry">Masonry</option>';
                html += '<option value="timber">Timber</option>';
                html += '</select>';
                html += '</div>';
                
                html += '<div class="form-group mt-4">';
                html += '<label for="anchor-type">Anchor Type:</label>';
                html += '<select id="anchor-type">';
                html += '<option value="expansion">Expansion Anchor</option>';
                html += '<option value="chemical">Chemical Anchor</option>';
                html += '<option value="throughbolt">Through Bolt</option>';
                html += '</select>';
                html += '</div>';
                
                optionsDiv.innerHTML = html;
            } else if (connectionType === 'foundation') {
                let html = '<div class="form-group">';
                html += '<label for="foundation-type">Foundation Type:</label>';
                html += '<select id="foundation-type">';
                html += '<option value="pad">Pad Foundation</option>';
                html += '<option value="strip">Strip Foundation</option>';
                html += '<option value="raft">Raft Foundation</option>';
                html += '</select>';
                html += '</div>';
                
                html += '<div class="form-group mt-4">';
                html += '<label for="concrete-grade">Concrete Grade:</label>';
                html += '<select id="concrete-grade">';
                html += '<option value="25">25 MPa</option>';
                html += '<option value="32">32 MPa</option>';
                html += '<option value="40">40 MPa</option>';
                html += '</select>';
                html += '</div>';
                
                html += '<div class="form-group mt-4">';
                html += '<label for="anchor-type">Anchor Type:</label>';
                html += '<select id="anchor-type">';
                html += '<option value="cast-in">Cast-in Anchor Bolts</option>';
                html += '<option value="post-installed">Post-Installed Anchors</option>';
                html += '</select>';
                html += '</div>';
                
                optionsDiv.innerHTML = html;
            }
        }
        
        // Find a section in the database
        function findSection(type, size) {
            if (!sectionDatabase[type]) return null;
            
            return sectionDatabase[type].find(section => section.size === size);
        }
        
        // Switch between different result views
        function switchResultView() {
            const selector = document.getElementById('result-view-selector');
            if (!selector) return;
            const viewType = selector.value;

            // Hide all views
            ['summary', 'detailed', 'visual', 'connections'].forEach(v => {
                const el = document.getElementById('result-' + v);
                if (el) el.classList.add('hidden');
            });

            // Show selected view
            const showEl = document.getElementById('result-' + viewType);
            if (showEl) showEl.classList.remove('hidden');

            // Initialize view if needed
            if (viewType === 'visual' && threeDScene === null) {
                initialize3DVisualization();
            }
        }

        // Initialize placeholder 3D scene
        function initialize3DVisualization() {
            // placeholder - real implementation would init three.js or similar
            threeDScene = { initialized: true };
            console.log('3D visualization initialized (placeholder)');
        }

        // Switch between connection views
        function switchConnectionView() {
            const viewType = document.getElementById('connection-view')?.value || 'single';
            updateConnectionDrawing(viewType);
            updateConnectionSpecs(viewType);
        }

        function updateConnectionDrawing(viewType) {
            console.log('updateConnectionDrawing:', viewType);
            // placeholder
        }
        function updateConnectionSpecs(viewType) {
            console.log('updateConnectionSpecs:', viewType);
            // placeholder
        }

        // Calculate section moment capacity (AS 4100-2020) - simplified
        function calculateMomentCapacity(section, axis = 'x', steelGrade = 'AS3679-300') {
            if (!section) return 0;
            const Z = axis === 'x' ? (section.Zx || 0) : (section.Zy || 0);
            const fy = (CONSTANTS.STEEL_GRADE[steelGrade] || CONSTANTS.STEEL_GRADE['AS3679-300']).fy;
            const Ms = Z * fy / 1e6; // kNm
            return CONSTANTS.PHI.MOMENT * Ms;
        }

        // Calculate section shear capacity (AS 4100-2020) - robust fallback logic
        function calculateShearCapacity(section, axis = 'x', steelGrade = 'AS3679-300') {
            if (!section) return 0;
            let Av = section.Av || section.area || 0;

            // Try to estimate Av for common shape properties if area not explicitly provided
            if (!Av) {
                if ('tw' in section && 'depth' in section) {
                    // approximate shear area for I/T shapes as web area
                    Av = section.tw * (section.depth - 2 * (section.tf || 0));
                } else if ('diameter' in section && 'thickness' in section) {
                    Av = 0.6 * Math.PI * section.diameter * section.thickness;
                } else if ('leg' in section && 'thickness' in section) {
                    Av = 2 * 0.6 * section.leg * section.thickness;
                } else {
                    Av = 1; // fallback non-zero to avoid zero-division later
                }
            }

            const fy = (CONSTANTS.STEEL_GRADE[steelGrade] || CONSTANTS.STEEL_GRADE['AS3679-300']).fy;
            const Vw = 0.6 * fy * Av / 1000; // kN
            return CONSTANTS.PHI.SHEAR * Vw;
        }

        // Calculate member compression capacity (simplified AS 4100-2020)
        function calculateCompressionCapacity(section, steelGrade = 'AS3679-300', effectiveLength = 3000) {
            if (!section) return 0;
            let Ag = section.area || 0;

            if (!Ag) {
                if ('tw' in section && 'tf' in section && 'width' in section && 'depth' in section) {
                    Ag = 2 * section.width * section.tf + (section.depth - 2 * section.tf) * section.tw;
                } else if ('diameter' in section && 'thickness' in section) {
                    Ag = Math.PI * section.diameter * section.thickness;
                } else if ('leg' in section && 'thickness' in section) {
                    Ag = 2 * section.leg * section.thickness - section.thickness * section.thickness;
                } else {
                    Ag = Math.max(1, section.area || 1); // fallback
                }
            }

            const rx = Math.sqrt((section.Ix || 1) / Ag);
            const ry = Math.sqrt((section.Iy || 1) / Ag);
            const slendernessX = effectiveLength / rx;
            const slendernessY = effectiveLength / ry;
            const slenderness = Math.max(slendernessX, slendernessY);

            const fy = (CONSTANTS.STEEL_GRADE[steelGrade] || CONSTANTS.STEEL_GRADE['AS3679-300']).fy;
            const lambdaN = slenderness / Math.sqrt(250 / fy);

            let alphaC = 0;
            if (lambdaN <= 1.5) {
                alphaC = Math.sqrt(Math.max(0, 1 - Math.pow(lambdaN / 1.5, 2)));
            } else {
                // simplified post-limit behaviour (placeholder)
                alphaC = Math.max(0, 1.5 / lambdaN * 0.1);
            }

            const Ns = fy * Ag / 1000; // kN
            const Nc = alphaC * Ns;
            return CONSTANTS.PHI.COMPRESSION * Nc;
        }

        // Calculate member deflection (simplified formulas)
        function calculateDeflection(section, steelGrade = 'AS3679-300', length = 3000, load = 1, loadType = 'uniform') {
            if (!section) return 0;
            const E = (CONSTANTS.STEEL_GRADE[steelGrade] || CONSTANTS.STEEL_GRADE['AS3679-300']).E;
            const I = section.Ix || 1;
            let deflection = 0;
            const w = load; // uniform load intensity (kN/m) expected, or point load magnitude in kN

            if (loadType === 'uniform') {
                // w in kN/m, length in mm -> convert length to m for formula consistency
                const Lm = length / 1000;
                deflection = 5 * w * Math.pow(Lm, 4) / (384 * E * (I / 1e12)); // convert I mm^4 -> m^4
                deflection = deflection * 1000; // result in mm
            } else if (loadType === 'point') {
                const Lm = length / 1000;
                deflection = w * Math.pow(Lm, 3) / (48 * E * (I / 1e12));
                deflection = deflection * 1000;
            } else if (loadType === 'triangular') {
                const Lm = length / 1000;
                deflection = 0.13 * w * Math.pow(Lm, 4) / (E * (I / 1e12));
                deflection = deflection * 1000;
            } else {
                deflection = 0;
            }

            return Math.abs(deflection);
        }

        // Design bolted connection (simplified placeholder)
        function designBoltedConnection(section, connectionType, steelGrade = 'AS3679-300', shearForce = 0, connectionData = {}) {
            if (!section) return null;
            const boltDiameter = parseInt((connectionData.boltDiameter || 'M16').replace(/[^0-9]/g, ''), 10) || 16;
            const boltGradeProps = CONSTANTS.BOLT_GRADE[connectionData.boltGrade] || CONSTANTS.BOLT_GRADE['8.8'];

            // bolt area (mm^2)
            const Ab = Math.PI * Math.pow(boltDiameter, 2) / 4;
            const boltShearCapacity = (CONSTANTS.PHI.BOLT_SHEAR * 0.62 * (boltGradeProps.fub || 800) * Ab) / 1000; // kN

            let plateThickness = 8;
            if (connectionType === 'column' || connectionType === 'beam') {
                plateThickness = Math.max(10, Math.ceil((section.tf || 8) * 1.2));
            } else if (connectionType === 'wall') {
                plateThickness = Math.max(8, Math.ceil((section.tw || 6) * 0.9));
            } else if (connectionType === 'foundation') {
                plateThickness = Math.max(16, Math.ceil((section.tf || 8) * 1.2));
            }

            const plateCapacity = (CONSTANTS.PHI.BEARING * ((CONSTANTS.STEEL_GRADE[steelGrade] || {}).fy || 250) * plateThickness * boltDiameter) / 1000; // kN (simplified)
            const weldLength = 2 * ((section.width || 100) + (section.depth || 100)); // mm - placeholder
            const weldCapacity = weldLength * 4.0 / 1000; // kN placeholder

            return {
                boltShearCapacity,
                plateCapacity,
                weldCapacity,
                plateThickness
            };
        }

        // Generate design results
        function generateResults() {
            if (!sectionData || !loadingData) {
                console.error('Missing section or loading data');
                return;
            }
            
            // Get section information
            const section = sectionData.section;
            const steelGrade = sectionData.steelGrade;
            const memberLength = sectionData.length;
            
            if (!section) {
                showNotification('Section not found', 'error');
                return;
            }
            
            // Calculate total design force
            const totalShearForce = loadingData.deadLoad + loadingData.liveLoad;
            const totalBendingMoment = totalShearForce * memberLength / 4000; // Simple estimate for uniform load
            
            // Calculate member capacities
            const momentCapacity = calculateMomentCapacity(section, 'x', steelGrade);
            const shearCapacity = calculateShearCapacity(section, 'x', steelGrade);
            let compressionCapacity = 0;
            
            if (sectionData.memberType === 'column' || sectionData.memberType === 'brace') {
                compressionCapacity = calculateCompressionCapacity(section, steelGrade, memberLength);
            }
            
            // Calculate deflection
            const deflection = calculateDeflection(
                section, steelGrade, memberLength, totalShearForce, loadingData.loadType || 'uniform'
            );
            
            // Calculate allowable deflection (typically span/300 for serviceability)
            const allowableDeflection = memberLength / 300;
            
            // Calculate utilization ratios
            const momentUtilization = totalBendingMoment / momentCapacity;
            const shearUtilization = totalShearForce / shearCapacity;
            const deflectionUtilization = deflection / allowableDeflection;
            
            // Design connection
            const connection = designBoltedConnection(
                section, connectionData.connectionType, steelGrade, totalShearForce, connectionData
            );
            
            // Update the results table
            updateResultsTables(section, steelGrade, momentCapacity, shearCapacity, compressionCapacity, 
                              totalBendingMoment, totalShearForce, deflection, allowableDeflection,
                              momentUtilization, shearUtilization, deflectionUtilization, connection);
            
            // Generate fabrication instructions
            document.querySelector('.fabrication-instructions pre').textContent = 
                generateFabricationInstructions(section, connection, connectionData);
            
            // Draw shop drawing
            drawShopDrawing(section, connection, connectionData);
            
            // Update detailed analysis
            updateDetailedAnalysis(section, steelGrade, memberLength, loadingData);
            
            // Update connection specs
            updateConnectionSpecs('main');
            
            // Show notification
            showNotification('Design calculation completed successfully', 'success');
        }
        
        // Update results tables
        function updateResultsTables(section, steelGrade, momentCapacity, shearCapacity, compressionCapacity,
                                  totalBendingMoment, totalShearForce, deflection, allowableDeflection,
                                  momentUtilization, shearUtilization, deflectionUtilization, connection) {
            
            // Update member capacities table
            const memberTable = document.querySelector('#result-summary table:first-of-type');
            
            // Update moment capacity row
            memberTable.rows[1].cells[1].textContent = momentCapacity.toFixed(2) + ' kNm';
            memberTable.rows[1].cells[2].textContent = totalBendingMoment.toFixed(2) + ' kNm';
            
            const momentStatus = getStatusClass(momentUtilization);
            memberTable.rows[1].cells[3].innerHTML = 
                `<span class="status ${momentStatus}">${(momentUtilization * 100).toFixed(1)}%</span>`;
            
            // Update shear capacity row
            memberTable.rows[2].cells[1].textContent = shearCapacity.toFixed(2) + ' kN';
            memberTable.rows[2].cells[2].textContent = totalShearForce.toFixed(2) + ' kN';
            
            const shearStatus = getStatusClass(shearUtilization);
            memberTable.rows[2].cells[3].innerHTML = 
                `<span class="status ${shearStatus}">${(shearUtilization * 100).toFixed(1)}%</span>`;
            
            // Update compression capacity row if applicable
            if (compressionCapacity > 0) {
                memberTable.rows[3].cells[1].textContent = compressionCapacity.toFixed(2) + ' kN';
                memberTable.rows[3].cells[2].textContent = 'N/A';
                memberTable.rows[3].cells[3].textContent = 'N/A';
            }
            
            // Update deflection row
            memberTable.rows[4].cells[1].textContent = deflection.toFixed(2) + ' mm';
            memberTable.rows[4].cells[2].textContent = allowableDeflection.toFixed(2) + ' mm';
            
            const deflectionStatus = getStatusClass(deflectionUtilization);
            memberTable.rows[4].cells[3].innerHTML = 
                `<span class="status ${deflectionStatus}">${(deflectionUtilization * 100).toFixed(1)}%</span>`;
            
            // Update section properties table
            const sectionTable = document.querySelector('#result-summary table:nth-of-type(2)');
            
            // Update section information
            sectionTable.rows[1].cells[1].textContent = section.size;
            sectionTable.rows[2].cells[1].textContent = section.mass + ' kg/m';
            sectionTable.rows[3].cells[1].textContent = 'Grade ' + steelGrade;
            
            // Update dimensions
            let dimensionText = '';
            if (section.hasOwnProperty('depth') && section.hasOwnProperty('width')) {
                dimensionText = `${section.depth}×${section.width} mm`;
            } else if (section.hasOwnProperty('width')) {
                dimensionText = `${section.width} mm`;
            } else if (section.hasOwnProperty('diameter')) {
                dimensionText = `${section.diameter} mm diameter`;
            } else if (section.hasOwnProperty('leg')) {
                dimensionText = `${section.leg}×${section.leg} mm`;
            } else if (section.hasOwnProperty('legH')) {
                dimensionText = `${section.legH}×${section.legV} mm`;
            }
            sectionTable.rows[4].cells[1].textContent = dimensionText;
            
            // Update connection design table
            if (connection) {
                const connectionTable = document.querySelector('#result-summary table:nth-of-type(3)');
                
                connectionTable.rows[1].cells[1].textContent = connectionData.connectionType.charAt(0).toUpperCase() + 
                                                              connectionData.connectionType.slice(1);
                connectionTable.rows[2].cells[1].textContent = connectionData.connectionMethod.charAt(0).toUpperCase() + 
                                                              connectionData.connectionMethod.slice(1);
                connectionTable.rows[3].cells[1].textContent = `${connection.numBolts}× ${connection.boltDiameter} Grade ${connection.boltGrade}`;
                connectionTable.rows[4].cells[1].textContent = connection.plateThickness + ' mm';
                connectionTable.rows[5].cells[1].textContent = `${connection.plateWidth}×${connection.plateHeight} mm`;
                connectionTable.rows[6].cells[1].textContent = `${connection.weldSize} mm ${connection.weldType}`;
                connectionTable.rows[7].cells[1].textContent = connection.shearCapacity.toFixed(2) + ' kN';
                
                const connectionStatus = connection.adequate ? 'status-ok' : 'status-error';
                const connectionText = connection.adequate ? 'ADEQUATE' : 'INADEQUATE';
                connectionTable.rows[8].cells[1].innerHTML = `<span class="status ${connectionStatus}">${connectionText}</span>`;
            }
        }
        
        // Update detailed analysis
        function updateDetailedAnalysis(section, steelGrade, memberLength, loadingData) {
            // Get canvas
            const canvas = document.getElementById('detailed-analysis');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw member
            const margin = 40;
            const memberY = canvas.height / 3;
            const memberLength_px = canvas.width - 2 * margin;
            const memberDepth_px = 30;
            
            // Draw member outline
            ctx.fillStyle = '#ccc';
            ctx.fillRect(margin, memberY - memberDepth_px/2, memberLength_px, memberDepth_px);
            
            // Draw supports
            drawSupport(ctx, margin, memberY + memberDepth_px/2, 'fixed');
            drawSupport(ctx, margin + memberLength_px, memberY + memberDepth_px/2, 'roller');
            
            // Draw load
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            
            if (loadingData.loadType === 'uniform') {
                // Draw uniform load
                const arrowCount = 10;
                const arrowSpacing = memberLength_px / arrowCount;
                const arrowHeight = 60;
                
                for (let i = 0; i < arrowCount; i++) {
                    const x = margin + i * arrowSpacing + arrowSpacing/2;
                    drawArrow(ctx, x, memberY - memberDepth_px/2 - 10, x, memberY - memberDepth_px/2 - arrowHeight);
                }
                
                // Draw load value
                ctx.fillStyle = '#000';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${(loadingData.deadLoad + loadingData.liveLoad).toFixed(2)} kN total`, 
                            canvas.width/2, memberY - memberDepth_px/2 - arrowHeight - 10);
                
            } else if (loadingData.loadType === 'point') {
                // Draw point load
                const x = margin + memberLength_px * loadingData.pointPosition;
                const arrowHeight = 60;
                
                drawArrow(ctx, x, memberY - memberDepth_px/2 - 10, x, memberY - memberDepth_px/2 - arrowHeight);
                
                // Draw load value
                ctx.fillStyle = '#000';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${(loadingData.deadLoad + loadingData.liveLoad).toFixed(2)} kN`, 
                            x, memberY - memberDepth_px/2 - arrowHeight - 10);
            }
            
            // Draw bending moment diagram
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const momentY = canvas.height * 2/3;
            const momentScale = 100; // Scale factor for moment diagram
            
            ctx.moveTo(margin, momentY);
            
            if (loadingData.loadType === 'uniform') {
                // Parabolic moment diagram for uniform load
                for (let i = 0; i <= 100; i++) {
                    const x_ratio = i / 100;
                    const x = margin + x_ratio * memberLength_px;
                    
                    // M = wL^2/8 * 4x/L * (1 - x/L) for simply supported beam with UDL
                    const total_load = loadingData.deadLoad + loadingData.liveLoad;
                    const moment = total_load * Math.pow(memberLength/1000, 2)/8 * 4 * x_ratio * (1 - x_ratio);
                    const y = momentY + moment * momentScale;
                    
                    ctx.lineTo(x, y);
                }
            } else if (loadingData.loadType === 'point') {
                // Triangular moment diagram for point load
                const pointPos = loadingData.pointPosition;
                const total_load = loadingData.deadLoad + loadingData.liveLoad;
                const max_moment = total_load * (memberLength/1000) * pointPos * (1 - pointPos);
                
                // Left segment
                for (let i = 0; i <= pointPos * 100; i++) {
                    const x_ratio = i / 100;
                    const x = margin + x_ratio * memberLength_px;
                    
                    // M = Px(1-a/L) for 0 ≤ x ≤ a
                    const moment = total_load * (x_ratio / pointPos) * max_moment;
                    const y = momentY + moment * momentScale;
                    
                    ctx.lineTo(x, y);
                }
                
                // Right segment
                for (let i = Math.ceil(pointPos * 100); i <= 100; i++) {
                    const x_ratio = i / 100;
                    const x = margin + x_ratio * memberLength_px;
                    
                    // M = P(L-x)a/L for a ≤ x ≤ L
                    const moment = total_load * ((1 - x_ratio) / (1 - pointPos)) * max_moment;
                    const y = momentY + moment * momentScale;
                    
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            
            // Moment diagram axis
            ctx.beginPath();
            ctx.moveTo(margin, momentY);
            ctx.lineTo(margin + memberLength_px, momentY);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#000';
            ctx.font = '14px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('Bending Moment (kNm)', margin - 10, momentY);
            
            // Draw maximum moment value
            let maxMoment = 0;
            
            if (loadingData.loadType === 'uniform') {
                // Max moment for uniform load is at midspan, M = wL²/8
                const totalLoad = loadingData.deadLoad + loadingData.liveLoad;
                maxMoment = totalLoad * Math.pow(memberLength/1000, 2) / 8;
            } else if (loadingData.loadType === 'point') {
                // Max moment for point load at position a is M = Pa(1-a/L)
                const totalLoad = loadingData.deadLoad + loadingData.liveLoad;
                const a = loadingData.pointPosition;
                maxMoment = totalLoad * memberLength/1000 * a * (1 - a);
            }
            
            const maxMomentX = margin + memberLength_px/2; // Simplified - assumes max is at midspan
            const maxMomentY = momentY + maxMoment * momentScale;
            
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.arc(maxMomentX, maxMomentY, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.textAlign = 'left';
            ctx.fillText(`Max: ${maxMoment.toFixed(2)} kNm`, maxMomentX + 10, maxMomentY);
            
            // Update analysis notes
            const notesList = document.getElementById('analysis-notes');
            if (notesList) {
                notesList.innerHTML = '';
                
                // Add notes about the analysis
                addAnalysisNote(notesList, `Member: ${section.size} (${section.mass} kg/m), Grade ${steelGrade} steel`);
                addAnalysisNote(notesList, `Span: ${(memberLength/1000).toFixed(2)} m, ${loadingData.loadType} load`);
                addAnalysisNote(notesList, `Maximum moment: ${maxMoment.toFixed(2)} kNm`);
                
                // Calculate maximum deflection
                const E = CONSTANTS.STEEL_GRADE[steelGrade].E;
                const I = section.Ix;
                let maxDeflection = 0;
                
                if (loadingData.loadType === 'uniform') {
                    // Max deflection for uniform load, δ = 5wL⁴/(384EI)
                    const totalLoad = loadingData.deadLoad + loadingData.liveLoad;
                    const w = totalLoad / (memberLength/1000); // kN/m
                    maxDeflection = 5 * w * Math.pow(memberLength, 4) / (384 * E * I) * 1e9; // mm
                } else if (loadingData.loadType === 'point') {
                    // Max deflection for point load at midspan, δ = PL³/(48EI)
                    const totalLoad = loadingData.deadLoad + loadingData.liveLoad;
                    maxDeflection = totalLoad * Math.pow(memberLength, 3) / (48 * E * I) * 1e9; // mm
                }
                
                addAnalysisNote(notesList, `Maximum deflection: ${maxDeflection.toFixed(2)} mm`);
                addAnalysisNote(notesList, `Allowable deflection (L/300): ${(memberLength/300).toFixed(2)} mm`);
                
                // Note about load combination
                addAnalysisNote(notesList, `Load combination: 1.2G + 1.5Q (${loadingData.deadLoad} kN dead load + ${loadingData.liveLoad} kN live load)`);
                
                // Add section capacity notes
                const momentCapacity = calculateMomentCapacity(section, 'x', steelGrade);
                const shearCapacity = calculateShearCapacity(section, 'x', steelGrade);
                
                addAnalysisNote(notesList, `Section moment capacity: ${momentCapacity.toFixed(2)} kNm (${((maxMoment/momentCapacity)*100).toFixed(1)}% utilized)`);
                
                // Calculate maximum shear
                let maxShear = 0;
                if (loadingData.loadType === 'uniform') {
                    // Max shear for uniform load is at supports, V = wL/2
                    const totalLoad = loadingData.deadLoad + loadingData.liveLoad;
                    maxShear = totalLoad;
                } else if (loadingData.loadType === 'point') {
                    // Max shear for point load
                    const totalLoad = loadingData.deadLoad + loadingData.liveLoad;
                    maxShear = totalLoad;
                }
                
                addAnalysisNote(notesList, `Section shear capacity: ${shearCapacity.toFixed(2)} kN (${((maxShear/shearCapacity)*100).toFixed(1)}% utilized)`);
            }
            
            // Update load combinations table
            updateLoadCombinations();
        }
        
        // Add an analysis note
        function addAnalysisNote(notesList, text) {
            const li = document.createElement('li');
            li.textContent = text;
            notesList.appendChild(li);
        }
        
        // Update load combinations table
        function updateLoadCombinations                document.getElementById('point-load-options').classList.toggle('hidden', loadType !== 'point');
            });
            
            // Form validation
            document.querySelectorAll('input[type="number"]').forEach(function(input) {
                input.addEventListener('input', validateInput);
            });
            
            // Loading type radio buttons
            document.querySelectorAll('input[name="loading-type"]').forEach(function(radio) {
                radio.addEventListener('change', function() {
                    toggleLoadingType(this.value);
                });
            });
            
            // Live load type dropdown
            document.getElementById('live-load-type').addEventListener('change', function() {
                document.getElementById('custom-live-load').classList.toggle('hidden', this.value !== 'custom');
            });
            
            // Snow load region dropdown
            document.getElementById('snow-load-region').addEventListener('change', function() {
                document.getElementById('custom-snow-load').classList.toggle('hidden', this.value !== 'custom');
            });
            
            // Load combination standard dropdown
            document.getElementById('load-combination-standard').addEventListener('change', function() {
                document.getElementById('standard-combinations').classList.toggle('hidden', this.value !== 'as1170');
                document.getElementById('custom-combinations').classList.toggle('hidden', this.value !== 'custom');
            });
            
            // Result view selector
            document.getElementById('result-view-selector').addEventListener('change', switchResultView);
        }
        
        // Setup drag and drop functionality
        function setupDragAndDrop() {
            const dropArea = document.getElementById('drop-area');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight() {
                dropArea.classList.add('drag-over');
            }
            
            function unhighlight() {
                dropArea.classList.remove('drag-over');
            }
            
            dropArea.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length) {
                    handleFileUpload({ target: { files: files } });
                }
            }
        }
        
        // Set up keyboard navigation
        function setupKeyboardNavigation() {
            document.addEventListener('keydown', function(e) {
                // Enter key for selection
                if (e.key === 'Enter') {
                    const focused = document.activeElement;
                    if (focused && focused.classList.contains('choice-card')) {
                        focused.click();
                    }
                }
                
                // Arrow keys for navigation
                if (e.key === 'ArrowRight' && !document.getElementById('next-button').disabled) {
                    nextStep();
                } else if (e.key === 'ArrowLeft' && !document.getElementById('prev-button').disabled) {
                    previousStep();
                }
            });
        }
        
        // Check for saved preferences
        function checkSavedPreferences() {
            // Check if dark mode was previously enabled
            const darkModePref = localStorage.getItem('darkMode');
            if (darkModePref === 'true') {
                toggleDarkMode();
            }
        }
        
        // Toggle dark mode
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            isDarkMode = document.body.classList.contains('dark-mode');
            
            // Update icon
            const themeToggle = document.querySelector('.theme-toggle');
            themeToggle.innerHTML = isDarkMode ? '☀️' : '🌙';
            
            // Save preference
            localStorage.setItem('darkMode', isDarkMode);
        }
        
        // Select design type
        function selectDesignType(type) {
            designType = type;
            
            // Update UI
            document.getElementById('single-member').classList.remove('selected');
            document.getElementById('frame-design').classList.remove('selected');
            
            document.getElementById(type + '-member').classList.add('selected');
            document.getElementById('next-button').disabled = false;
            
            // Update ARIA attributes
            document.getElementById('single-member').setAttribute('aria-pressed', type === 'single');
            document.getElementById('frame-design').setAttribute('aria-pressed', type === 'frame');
            
            // Show notification
            showNotification(`${type.charAt(0).toUpperCase() + type.slice(1)} member design selected`, 'success');
        }
        
        // Navigate to next step
        function nextStep() {
            // Validate current step data
            if (!validateCurrentStep()) {
                showNotification('Please correct the errors before continuing', 'error');
                return;
            }
            
            // Save data from current step
            saveCurrentStepData();
            
            if (currentStep < 4) {
                currentStep++;
                updateStepDisplay();
                
                // Initialize the new step
                initializeStep(currentStep);
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            } else {
                // Finish the design
                downloadDesign();
            }
        }
        
        // Navigate to previous step
        function previousStep() {
            if (currentStep > 1) {
                currentStep--;
                updateStepDisplay();
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }
        
        // Go to a specific step (for step indicators)
        function goToStep(step) {
            if (step >= 1 && step <= currentStep && step <= 4) {
                currentStep = step;
                updateStepDisplay();
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }
        
        // Update step display
        function updateStepDisplay() {
            // Hide all steps
            document.getElementById('step1').classList.add('hidden');
            document.getElementById('step2').classList.add('hidden');
            document.getElementById('step3').classList.add('hidden');
            document.getElementById('step4').classList.add('hidden');
            
            // Show current step
            document.getElementById('step' + currentStep).classList.remove('hidden');
            
            // Update step indicators
            for (let i = 1; i <= 4; i++) {
                const indicator = document.getElementById('step' + i + '-indicator');
                indicator.classList.remove('active', 'completed');
                indicator.setAttribute('aria-selected', i === currentStep);
                indicator.tabIndex = i === currentStep ? 0 : -1;
                
                if (i < currentStep) {
                    indicator.classList.add('completed');
                } else if (i === currentStep) {
                    indicator.classList.add('active');
                }
            }
            
            // Update connecting lines
            for (let i = 1; i < 4; i++) {
                const line = document.getElementById('line' + i + '-' + (i+1));
                if (line) {
                    if (i < currentStep) {
                        line.classList.add('completed');
                    } else {
                        line.classList.remove('completed');
                    }
                }
            }
            
            // Update navigation buttons
            document.getElementById('prev-button').disabled = (currentStep === 1);
            
            const nextButton = document.getElementById('next-button');
            nextButton.textContent = (currentStep === 4) ? 'Download' : 'Next';
            
            if (currentStep === 1) {
                nextButton.disabled = (designType === null);
            } else {
                nextButton.disabled = false;
            }
        }
        
        // Initialize a step
        function initializeStep(step) {
            switch (step) {
                case 2:
                    // Member specifications
                    if (designType === 'single') {
                        document.getElementById('single-member-form').classList.remove('hidden');
                        document.getElementById('frame-design-form').classList.add('hidden');
                    } else {
                        document.getElementById('single-member-form').classList.add('hidden');
                        document.getElementById('frame-design-form').classList.remove('hidden');
                    }
                    break;
                    
                case 3:
                    // Initialize loading forms
                    toggleLoadingType('simple');
                    break;
                    
                case 4:
                    // Generate results
                    generateResults();
                    initializeVisualization();
                    break;
                    
                default:
                    break;
            }
        }
        
        // Validate current step
        function validateCurrentStep() {
            let isValid = true;
            
            switch (currentStep) {
                case 1:
                    // Validate design type selection
                    isValid = designType !== null;
                    break;
                    
                case 2:
                    // Validate member specifications
                    if (designType === 'single') {
                        // Validate member length
                        const memberLength = document.getElementById('member-length').value;
                        if (memberLength < 100) {
                            isValid = false;
                        }
                    } else {
                        // Validate frame dimensions if a frame is uploaded
                        if (uploadedImage) {
                            const frameWidth = document.getElementById('frame-width').value;
                            const frameHeight = document.getElementById('frame-height').value;
                            if (frameWidth < 1000 || frameHeight < 1000) {
                                isValid = false;
                            }
                        } else {
                            isValid = false;
                            showNotification('Please upload a frame sketch', 'error');
                        }
                    }
                    break;
                    
                case 3:
                    // Validate loading information
                    const deadLoad = parseFloat(document.getElementById('dead-load').value);
                    const liveLoad = parseFloat(document.getElementById('live-load').value);
                    
                    if (isNaN(deadLoad) || deadLoad < 0 || isNaN(liveLoad) || liveLoad < 0) {
                        isValid = false;
                    }
                    break;
                    
                default:
                    break;
            }
            
            return isValid;
        }
        
        // Validate individual input
        function validateInput(e) {
            const input = e.target;
            const value = parseFloat(input.value);
            const min = parseFloat(input.min);
            
            if (isNaN(value) || value < min) {
                input.setCustomValidity('Invalid value');
                input.classList.add('invalid');
            } else {
                input.setCustomValidity('');
                input.classList.remove('invalid');
            }
        }
        
        // Save data from the current step
        function saveCurrentStepData() {
            switch (currentStep) {
                case 2:
                    // Member specifications
                    if (designType === 'single') {
                        sectionData = {
                            memberType: document.getElementById('member-type').value,
                            sectionType: document.getElementById('section-type').value,
                            sectionSize: document.getElementById('section-size').value,
                            length: parseFloat(document.getElementById('member-length').value),
                            steelGrade: document.getElementById('steel-grade').value
                        };
                        
                        // Find section in database
                        sectionData.section = findSection(sectionData.sectionType, sectionData.sectionSize);
                        
                        // Get advanced connection data
                        connectionData = {
                            connectionType: document.getElementById('connection-type').value,
                            connectionMethod: document.getElementById('connection-method').value,
                            boltDiameter: document.getElementById('bolt-diameter').value,
                            boltGrade: document.getElementById('bolt-grade').value,
                            numBolts: parseInt(document.getElementById('num-bolts').value),
                            edgeDistance: parseFloat(document.getElementById('edge-distance').value),
                            weldSize: parseFloat(document.getElementById('weld-size').value),
                            weldType: document.getElementById('weld-type').value
                        };
                    } else {
                        // Frame data
                        connectionData = {
                            connectionType: document.getElementById('frame-connection-type').value,
                            connectionMethod: document.getElementById('frame-connection-method').value,
                            frameWidth: parseFloat(document.getElementById('frame-width').value),
                            frameHeight: parseFloat(document.getElementById('frame-height').value)
                        };
                    }
                    break;
                    
                case 3:
                    // Loading conditions
                    const loadingType = document.querySelector('input[name="loading-type"]:checked').value;
                    
                    if (loadingType === 'simple') {
                        loadingData = {
                            deadLoad: parseFloat(document.getElementById('dead-load').value),
                            liveLoad: parseFloat(document.getElementById('live-load').value),
                            windLoad: parseFloat(document.getElementById('wind-load').value),
                            snowLoad: parseFloat(document.getElementById('snow-load').value),
                            loadType: document.getElementById('load-type').value
                        };
                        
                        if (loadingData.loadType === 'point') {
                            loadingData.pointPosition = parseInt(document.getElementById('point-load-position').value) / 100;
                        }
                    } else {
                        // Advanced loading data
                        loadingData = {
                            advanced: true,
                            includeSelfWeight: document.getElementById('include-self-weight').checked,
                            permanentDistributed: parseFloat(document.getElementById('permanent-distributed-load').value),
                            permanentPoint: parseFloat(document.getElementById('permanent-point-load').value),
                            permanentPointPosition: parseFloat(document.getElementById('permanent-point-load